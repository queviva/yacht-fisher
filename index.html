<!doctype html><html lang="en">
    
<head>
<title>yacht~fisherman</title>
<meta name="viewport"
content="width=device-width, initial-scale=1.0">
<style id="demoStyles">

@font-face {
    font-family : luckiest;
    src : url(luckiest.ttf);
}

:root {
    
    --nose-hsla: hsla(0, 40%, 100%, 1);
    
    --nose-h: 0;
    --nose-s: 40%;
    --nose-l: 100%;
    --nose-a: 1;
                
    --lightness: hsl(
        var(--nose-h),
        var(--nose-s),
        var(--nose-l)
    );
    
    --midness: hsl(
        var(--nose-h),
        calc(0.7 * var(--nose-s)),
        calc(0.7 * var(--nose-l))
    );
    
    --darkness: hsl(
        var(--nose-h),
        var(--nose-s),
        calc(0.45 * var(--nose-l))
    );
    
    --blackness: hsl(
        var(--nose-h),
        var(--nose-s),
        calc(0.20 * var(--nose-l))
    );
                
    --main-color: var(--lightness);
    --greyed-out: var(--darkness);
    --back-color: #666;
    --holder-back: #111;
    --faded-txt: hsla(
        var(--nose-h),
        var(--nose-s),
        var(--midness),
        0.5
    );
    
    --trans-speed: 0.3s;
    
}

* {
    box-sizing: border-box;
    word-wrap: break-word;
}

body {
    padding: 0;
    margin: 0;
    background-color: var(--back-color);
    font-size: 22px;
    text-align: justify;
    hyphens: auto;
}

.holder {
    
	position: relative;
    color: var(--main-color);
    background-color: var(--holder-back);
    margin: auto;
    width: 100%;
    max-width: 700px;
    
}

a {
    text-decoration: none;
    color: var(--darkness);
}

a:hover, a:visited {
    transition: color linear var(--trans-speed);
    color: var(--darkness);
}

pre {
    background-color: var(--midness);
    margin: 0px;
    padding: 10px;
    color: var(--lightness);
    overflow: auto;
}

emp {
    font-family: luckiest;
    font-style: italic;
    font-weight: bold;
    -webkit-text-stroke: 2px #888;
}

sup {
    font-size: 0.5em;
    font-style: italic;
}

hr {
    border-top: 1px solid var(--blackness);
    border-bottom: none;
    border-left: none;
    border-right: none;
    margin: 7px 0px 7px 0px;
}

.qa > div > a, .qa > div  > a,
.qb > div > a, .qb > div  > a,
.qa > div > a:hover, .qa > div  > a:visited,
.qb > div > a:hover, .qb > div> a:visited
{
    color: var(--lightness);
}

.qr > b {
    color: var(--darkness);
}

.qa > div > b,
.qb > div > b {
    color: var(--lightness);
}

.qr {
    padding: 10px;
}

.qa:after {
    content: "";
    display: table;
    clear: both;
}

.qa > div {
    float: left;
    padding: 10px;
    height: auto;
}

.qa > div:nth-child(1) {
  width: 65%;
}

.qa > div:nth-child(2) {
  width: 35%;
}

.qb:after {
    content: "";
    display: table;
    clear: both;
}

.qb > div {
    float: left;
    padding: 10px;
    height: auto;
}

.qb > div:nth-child(1) {
  width: 35%;
}

.qb > div:nth-child(2) {
  width: 65%;
}

.qa, .qb {
    color: var(--lightness);
}

.mobr {
    display: none;
}

.hobr {
    display: inline-block;
}

.abhr {
    display: none;
}

/*possibly a portrait mobi-fone*/
@media screen and (max-width:500px) {

	.qa > div:nth-child(1),
	.qa > div:nth-child(2),
	.qb > div:nth-child(1),
	.qb > div:nth-child(2)
	{
    	width: 100%;
    }
    
    .mobr {
        display: inline-block;
    }
    .hobr {
        display: none;
    }
    .abhr {
        display: block;
    }
    ul {
        text-align: left;
    }

}

/*possibly a mobile landscraper*/
@media screen and (orientation: landscape) and (max-width: 760px) {

    
}

.signature {
    text-align: right;
    font-family: 'luckiest';
    font-style: italic;
    height: 200px;
    color: var(--darkness);
    -webkit-text-stroke: 1px var(--midness);
    user-select:none;
}

</style>
<style id="chartStyles">

#chart {
    height: 200px;
    width: 100%;
    display: grid;
    grid-column-gap: 2px;
    grid-row-gap: 5px;
    --barH: 50px;
    cursor: auto;
    overflow: scroll;
    resize: vertical;
}

#chart > div {
    position: relative;
    text-align: center;
    height: var(--barH);
}

#chart > div > div {
    position: absolute;
    width: 100%;
}

.msg {
    text-align: center;
    grid-column: 1 / -1;
    cursor: pointer;
}

.txt {
    color: var(--darkness);
    transition: color linear 250ms;
}

.txt:hover {
    color: var(--midness);
    transition: color linear 250ms;
}

#dataDiv {
    text-align: justify;
}

</style>
<script defer src="nanopicker.js"></script>
</head>

<body>
<div class="holder">
    
    <div id="chart" class="qr"></div>

    <div intro class="qr">
    <hr><br>
    naive shuffling has <emp>No bias</emp>,
    despite furious insistance to the contrary;
    <br><br>
    this implimentation of the
    <b><i>yacht~fisherman</i></b> algorithm
    demonstrates that outcomes from the
    most blatantly amateur method of
    rearrangement can not be distinguished
    from random - besides the obvious reaction
    to viewing the histograms, data from these trials
    easily passes a <i>runs test</i>
    [among other flavors of random candy];
    it neither displays a preference for any
    particular permutation
    nor contains any cyclical pattern
    </div>

    <hr>
    <div scramcode class="qr">
    in javascript, the <i>yacht-fischermann</i>
    algorithm requires only a single line of code:
    <br><br>
    <pre>
        
const scramble = v => v.forEach((_, i) => v.push(
    v.splice(~~(Math.random() * (v.length - i)), 1)[0]
));
    </pre>
    </div>
    
    <hr>
    <div history class="qa">

        <div>
            Yacht and Fleischermann developed the first
            workable model of the 17<sup>th</sup> century
            natural philosopher
            <a href="https://en.wikipedia.org/wiki/Naivety">
            Na&#239;vett&#233;'s</a> algorithm for
            <i>le brouilage d'un jeu de
            cartes &#224; jouer:</i>
        </div>
        
        <div class="hobr" style="text-align:center;">
            <svg viewbox="0 0 550 550"
             style="
                transform: scale(-1, 1);
                width:150px;
                --yacht-color: var(--midness);
                --xhull-color: #b0b;
                --xtower-color: #800;
                --xrod-color: #008;
                --xwindow-visibility: visible;
                --xwindow-color: #fb0;
             "
            >
                <use xlink:href="yacht.svg#ikon"
                 data-nose=":root" />
            </svg>
        </div>
    
    </div>

    <div shufflesteps class="qb">
        
        <div svg>
            <svg viewbox="0 0 550 550"
             style="
                width:100%;
                --xyacht-color: var(--blackness);
                --yacht-color: #111;
                background-image: linear-gradient(
                var(--blackness), var(--midness)
                );
             "
            >
                <use data-nose=":root"
                xlink:href="yacht.svg#ikon" />
            </svg>
        </div>
        
        <div>
            <ul style="list-style-type:circle;">
            <li>pick a number from one to fifty-two</li>
            <li>place that card on the bottom of the deck</li>
            <li>pick a number from one to fifty-ONE</li>
            <li>place that card on the bottom of the deck</li>
            <li>pick a number from one to <i>fifty</i></li>
            <li>place that card on the  ...
                are you seeing a pattern yet?</li>
            </ul>
        </div>
    
    </div>
    
    <hr>
    <div YACHT_METHOD class="qr">
    a non-mutating evolution of the
    Yacht von Fleischerm&#228;nn algorithm
    might look like this, slightly shorter line,
    that dispenses with the heavy-handed <i>push()</i>:
    <br>
    <br>
    <pre>
        
const yacht = (v, r=[...v]) => v.map(() =>
    r.splice(~~(Math.random() * r.length), 1)[0]
);
    </pre>
    <br>
    this returns a new array, as a map,
    <i>without</i> mutating the original array;
    the default parameter
    <i>r=[...v]</i> uses a spread operator to
    make a safe copy of the input value for
    <i>splice()</i> to destroy
    </div>
    
    <hr>
    <div durstenshuffeld class="qr">
    but you insist upon using some silly
    <i>durstenshuffeld</i> fiasco!
    well then, at least compose it in some
    reasonable, <i>forward iterating</i>,
    and concise manner, you fool:
    <br><br>
    
    <pre>
        
const yacht-fisherfeld = v =>

    [...v].map((x, i, r,

        j = ~~(Math.random() * (r.length - i)) + i

    ) => ([x, r[j]] = [r[j], x], x)
        
);
    </pre>
    <br>
    that method preserves the original array
    with a <i>map()</i>, floors the random float
    using a <i>double bitwise~not</i>,
    and swaps array values with a destructured
    assignment
    </div>
    
    <div id="dataDiv" class="qr"></div>

    <div id="sig" class="qr signature"><i>~queviva</i></div>

</div>
</body>

<script>

new function () {

    // prefs {

    const loops = 100000;
    const trials = 5;
    const size = 4;
    const showTitle = size < 5;
    const showRands = false;
    
    const hiColor = 'var(--midness)';
    const loColor = 'var(--darkness)';
    
    const message = 'click to show raw & rerun';

    //}

    // utils {
    
    const log = console.log;
    const abs = Math.abs;
    const max = Math.max;

    const rand = () => [...crypto.getRandomValues(
        new Uint32Array(1)
    )].map(v => v / 4294967296.5)[0];

    const randArray = n => [...crypto.getRandomValues(
        new Uint32Array(n)
    )].map(v => v / 4294967296.5);

    const fact = n => [...new Array(n-2)].reduce((v, _, i) =>
        v * (i + 3)
    , 2);
    
    const perm = a => a.length ? a.flatMap(b =>
        perm(a.filter(c => c !== b)).map(d => [b, ...d])
    ).map(f => f.join('')) : [[]];
        

    // }
    
    // SHUFFLE {

    const shuffle = [
        
    (v, r=[...v]) => v.map(() =>
        r.splice(~~(Math.random() * r.length), 1)[0]
    ),
    
    v => v.forEach((_, i) => v.push(
        v.splice(~~(Math.random() * (v.length - i)), 1)[0]
    ))
    
    ][0];
        
    //}

    // setup {
    
    const list = 'zyxwvutsrqp'.split('').splice(0, size);
    
    const perms = perm(list).reduce((o,k)=>({...o,[k]:0}),{});
    
    const ordList = Object.keys(perms).sort();
    
    const permLength = ordList.length;
    
    const perk = loops / permLength;

    const barH = parseInt(
        window.getComputedStyle(chart)
        .getPropertyValue('--barH'),10
    ) / 2;

    chart.style.gridTemplateColumns = 'repeat(' +
        permLength + ', 1fr)';

    chart.style.gridTemplateRows    = 'repeat(' +
        permLength + ', 1fr, auto)';

    const msg = document.createElement('div');
    msg.classList.add('msg');
            
    const txt = document.createElement('i');
    txt.classList.add('txt');
    txt.innerText = message;
    
    msg.appendChild(txt);
    
    //}
    
    // methods {
    
    const buildHead = () => {
    
        !showTitle ||
        
        ordList.forEach(v => {
    
            let tmp = document.createElement('div');
            tmp.innerHTML = v;
            tmp.style.color = '#fff';
            tmp.style.fontSize = '10px';
            chart.appendChild(tmp);
    
        });
    };
    
    const buildData = () => {
        
        let graph = { ...perms };
        
        for (let i=0; i < loops; i++) {
            
            /* shuffle[ONE]
            let Q = [...list];
            shuffle(Q);
            graph[Q.join('')]++;
            */
            
            // shuffle[ZER]
            graph[shuffle(list).join('')]++;
            
        }
        
        return graph;
        
    };
    
    const buildRows = () => {
        
        if (count < trials) {
        
            const x = buildData();
        
            Object.keys(x).forEach(k => x[k] -= perk);
        
            buildBars(x);
            
            if (showRands) {
        
                looping = setTimeout(() => {
                
                    const rands = { ...perms };
                
                    Object.keys(rands).forEach(k =>
                        rands[k] = rand() * 200 - 100
                    );
                
                    buildBars(rands);
                    
                    count++;
                    setTimeout(buildRows, 0);
                    
                }, 0);
        
            }
            else {
                count++;
                looping = setTimeout(buildRows, 0);
            }
        
            trialData.push(x);
        
        
        } else {
            
            chart.style.cursor = 'auto';
            chart.appendChild(msg);
            
        }
        
    };
    
    const buildBars = data => {
        
        const maxi = max(...(
            Object.values(data).map(v => abs(v))
        ));
        
        ordList.forEach(v => {

            let tmp = document.createElement('div');

            let bar = document.createElement('div');
            
            bar.style.fontSize = '10px';
          //bar.innerHTML = showTitle ? v : '';

            bar.style.height = barH * abs(data[v]) / maxi
                + 'px';

            if (data[v] >= 0) {

                bar.style.backgroundColor = hiColor;
                bar.style.bottom = '50%';

            }
            else {

                bar.style.backgroundColor = loColor;
                bar.style.top = '50%';

            }

            tmp.appendChild(bar);
            chart.appendChild(tmp);

        });
        
    };
    
    const genData = () => {
        clearTimeout(looping);
        chart.innerHTML = '';
        chart.style.cursor = 'wait';
        buildHead();
        count = 0;
        trialData = [];
        looping = setTimeout(buildRows, 0);
    }
    
    //}
    
    // looping vars {
    let looping, trialData, count;
    //}
    
    // add lizzers {
    
    sig.addEventListener('click', () => {
        sig.innerHTML = '~' +
        shuffle('queviva'.split('')).join('');
    });
    
    msg.addEventListener('click', () => {
        
        let dataCopy = [ ...trialData ];
        
        for (let i in dataCopy) {
            for (let j in dataCopy[i]) {
                dataCopy[i][j] = dataCopy[i][j].toFixed(3);
            }
        }
        
        dataDiv.innerHTML += (JSON.stringify(dataCopy))
        .replace(/,/g,', ');
        
        genData();
        
    });
    
    //}
    
    // init {
    
    genData();
    
    //}
    
}();

</script>

</html>