<!doctype html><html lang="en">
    
<head>
<title>yacht~fisherman</title>
<meta name="viewport"
content="width=device-width, initial-scale=1.0">
<style id="demoStyles">

@font-face {
    font-family : luckiest;
    src : url(luckiest.ttf);
}

:root {
    
    --nose-hsla: hsla(0, 40%, 100%, 1);
    
    --nose-h: 0;
    --nose-s: 40%;
    --nose-l: 100%;
    --nose-a: 1;
                
    --lightness: hsl(
        var(--nose-h),
        var(--nose-s),
        var(--nose-l)
    );
    
    --midness: hsl(
        var(--nose-h),
        calc(0.7 * var(--nose-s)),
        calc(0.65 * var(--nose-l))
    );
    
    --darkness: hsl(
        var(--nose-h),
        var(--nose-s),
        calc(0.45 * var(--nose-l))
    );
    
    --blackness: hsl(
        var(--nose-h),
        var(--nose-s),
        calc(0.20 * var(--nose-l))
    );
                
    --main-color: var(--lightness);
    --greyed-out: var(--darkness);
    --back-color: #666;
    --holder-back: #111;
    --faded-txt: hsla(
        var(--nose-h),
        var(--nose-s),
        var(--midness),
        0.5
    );
    
    --trans-speed: 0.3s;
    
}

* {
    box-sizing: border-box;
    word-wrap: break-word;
}

body {
    padding: 0;
    margin: 0;
    background-color: var(--back-color);
    font-size: 22px;
    text-align: justify;
    hyphens: auto;
}

.holder {
    
	position: relative;
    color: var(--main-color);
    background-color: var(--holder-back);
    margin: auto;
    width: 100%;
    max-width: 700px;
    
}

a {
    text-decoration: none;
    color: var(--darkness);
}

a:hover, a:visited {
    transition: color linear var(--trans-speed);
    color: var(--darkness);
}

pre {
    background-color: var(--blackness);
    margin: 0px;
    padding: 10px;
    color: var(--midness);
    overflow: auto;
}

emp {
    font-family: luckiest;
    font-style: italic;
    font-weight: bold;
    -webkit-text-stroke: 2px hsl(
        var(--nose-h),
        calc(0.2 * var(--nose-s)),
        calc(0.7 * var(--nose-l))
    );
}

sup {
    font-size: 0.5em;
    font-style: italic;
    text-decoration: underline;
    text-underline-position: under;
}

hr {
    border-top: 1px solid var(--blackness);
    border-bottom: none;
    border-left: none;
    border-right: none;
    margin: 7px 0px 7px 0px;
}

.qa > div > a, .qa > div  > a,
.qb > div > a, .qb > div  > a,
.qa > div > a:hover, .qa > div  > a:visited,
.qb > div > a:hover, .qb > div> a:visited
{
    color: var(--lightness);
}

.qr > b {
    color: var(--darkness);
}

.qa > div > b,
.qb > div > b {
    color: var(--lightness);
}

.qr {
    padding: 10px;
}

.qa:after {
    content: "";
    display: table;
    clear: both;
}

.qa > div {
    float: left;
    padding: 10px;
    height: auto;
}

.qa > div:nth-child(1) {
  width: 65%;
}

.qa > div:nth-child(2) {
  width: 35%;
}

.qb:after {
    content: "";
    display: table;
    clear: both;
}

.qb > div {
    float: left;
    padding: 10px;
    height: auto;
}

.qb > div:nth-child(1) {
  width: 35%;
}

.qb > div:nth-child(2) {
  width: 65%;
}

.qa, .qb {
    color: var(--lightness);
}

.mobr {
    display: none;
}

.hobr {
    display: inline-block;
}

.abhr {
    display: none;
}

/*possibly a portrait mobi-fone*/
@media screen and (max-width:500px) {

	.qa > div:nth-child(1),
	.qa > div:nth-child(2),
	.qb > div:nth-child(1),
	.qb > div:nth-child(2)
	{
    	width: 100%;
    }
    
    .mobr {
        display: inline-block;
    }
    .hobr {
        display: none;
    }
    .abhr {
        display: block;
    }
    ul {
        text-align: left;
    }

}

/*possibly a mobile landscraper*/
@media screen and (orientation: landscape) and (max-width: 760px) {

    
}

.signature {
    text-align: right;
    font-family: 'luckiest';
    font-style: italic;
    height: 200px;
    color: var(--blackness);
    -webkit-text-stroke: 1px var(--darkness);
    user-select:none;
}

</style>
<style id="chartStyles">

#chart {
    height: 200px;
    width: 100%;
    display: grid;
    grid-column-gap: 2px;
    grid-row-gap: 5px;
    --barH: 50px;
    cursor: auto;
    overflow: scroll;
    resize: vertical;
}

#chart > div {
    position: relative;
    text-align: center;
    height: var(--barH);
}

#chart > div > div {
    position: absolute;
    width: 100%;
}

.msg {
    text-align: center;
    grid-column: 1 / -1;
    cursor: pointer;
}

.txt {
    color: var(--darkness);
    transition: color linear 250ms;
}

.txt:hover {
    color: var(--midness);
    transition: color linear 250ms;
}

#dataDiv {
    text-align: justify;
}

</style>
<script defer src="nanopicker.js"></script>
</head>

<body>
<div class="holder">
    
    <div id="chart" class="qr"></div>

    <div no_bias class="qr">
    <hr><br>
    naive shuffling has <emp>No bias</emp>,
    despite furious insistance to the contrary;
    <br><br>
    this implimentation of the
    <b><i>yacht~fisherman</i></b> algorithm
    demonstrates that outcomes from the
    most blatantly amateur method of
    rearrangement can not be distinguished
    from random - besides the obvious fair
    distribution seen in these histograms,
    data from the trials easily passes a
    <i>runs test</i>
    [among other flavors of random candy];
    it neither displays a preference for any
    particular permutation
    nor contains any cyclical pattern
    </div>

    <hr>
    <div scram_code class="qr">
    in javascript, the <i>yacht-fischermann</i>
    algorithm requires only a single line of code:
    <br><br>
    <pre>
        
const yacht = v => v.forEach((_, i) => v.push(
    v.splice(~~(Math.random()*(v.length-i)),1)[0]
));
    </pre>
    </div>
    
    <hr>
    <div history class="qa">

        <div>
            Yacht and Fleischermann developed the first
            workable model of the 17<sup>th</sup> century
            natural philosopher
            <a href="https://en.wikipedia.org/wiki/Naivety">
            Na&#239;vett&#233;'s</a> algorithm for
            <i>le brouilage d'un jeu de
            cartes &#224; jouer:</i>
        </div>
        
        <div class="hobr" style="text-align:center;">
            <svg viewbox="0 0 550 550"
             style="
                transform: scale(-1, 1);
                width:150px;
                --yacht-color: var(--midness);
                --xhull-color: #b0b;
                --xtower-color: #800;
                --xrod-color: #008;
                --xwindow-visibility: visible;
                --xwindow-color: #fb0;
             "
            >
                <use xlink:href="yacht.svg#ikon"
                 data-nose=":root" />
            </svg>
        </div>
    
    </div>

    <div shuffle_steps class="qb">
        
        <div svg>
            <svg viewbox="0 0 550 550"
             style="
                width:100%;
                --yacht-color: #111;
                background-image: linear-gradient(
                var(--blackness), var(--midness)
                );
             "
            >
                <use data-nose=":root"
                xlink:href="yacht.svg#ikon" />
            </svg>
        </div>
        
        <div>
            <ul style="list-style-type:circle;">
            <li>pick a number from one to fifty-two</li>
            <li>place that card on the bottom of the deck</li>
            <li>pick a number from one to fifty-ONE</li>
            <li>place that card on the bottom of the deck</li>
            <li>pick a number from one to <i>fifty</i></li>
            <li>place that card on the  ...
                are you seeing a pattern yet?</li>
            </ul>
        </div>
    
    </div>
    
    <hr>
    <div YACHT_METHOD class="qr">
    
    a non-mutating evolution of the
    Yacht von Fleischerm&#228;nn algorithm
    might look like this, slightly shorter line,
    that dispenses with the heavy-handed <i>push()</i>:
    <br>
    <br>
    <pre>
        
const yacht = (v, r=[...v]) => v.map(() =>
    r.splice(~~(Math.random() * r.length), 1)[0]
);
    </pre>
    <br>
    this returns a new array, as a map,
    <i>without</i> mutating the original array;
    the default parameter
    <i>r=[...v]</i> uses a spread operator to
    make a copy of the input value for
    <i>splice()</i> to safely destroy;
    this code generated the values for the
    histograms
    </div>
    
    <hr>
    <div dursten_shuffeld class="qr">
        
    but you insist upon using some silly
    <i>durstenshuffeld</i> fiasco!
    well then, at least compose it in some
    reasonable, <i>forward iterating</i>,
    and concise manner, you fool:
    <br><br>
    
    <pre>
        
const yacht-fisherfeld = v =>

    [...v].map((x, i, r,

        j = ~~(Math.random() * (r.length - i)) + i

    ) => ([x, r[j]] = [r[j], x], x)
        
);
    </pre>
    <br>
    that  version of
    der &#8476;eichskanzler
    Yacht-heim von Fleischerm&#228;nntz
    method
    preserves the original array
    with a <i>map()</i>, floors the random float
    using a <i>double bitwise~not</i>,
    and swaps array values with a destructured
    assignment
    </div>
    
    <hr>
    <div cut class="qr">
        alright geniuses, is that the way people
        typically shuffle cards? huh?
        <i>no</i>
        <br><br>
        maybe we should write some code for
        <i>cutting</i> a deck:
        <br><br>
        
        <pre>
            
const cut = (v, r=[...v], l=r.length) => [
    ...r.splice(~~(l/2 - 0.1*l + Math.random()*0.2*l)),
    ...r
];
        </pre><br>
        
        that takes an array <i>v</i>,
        makes a reference copy of it <i>r</i>
        [to keep the original array unmutated],
        creates a variable equal to the size
        of the deck <i>l</i>,
        then returns an array composed from
        the spread values of the copy
        [split at a position
        plus-or-minus ten percent from the
        middle of the deck], and the spread
        values of the reliquum
        <br><br>
        when the 17<sup>th</sup> century
        natural philosopher
        <a href="https://en.wikipedia.org/wiki/Naivety">
        Na&#239;vett&#233;</a> attempted to
        program a smaller version of that code,
        he <i>lost both his eyes</i>
        
    </div>
    
    <hr>
    <div riffle class="qr">
        
        after his beheading for treason,
        the 17<sup>th</sup> century
        natural philosopher
        <a href="https://en.wikipedia.org/wiki/Naivety">
        Na&#239;vett&#233;</a>
        wrote several prominant papers,
        one of which included this method
        for <i>riffle shuffling</i> a deck of cards:
        <br><br>
        
        <pre>
            
const riffle = (
    v,
    k=[...v],
    l=v.length,
    r=[k.splice(0, ~~(l/2 - l*0.1 + Math.random()*l* 0.2)), k],
    t=[],
    s=~~(Math.random()*2)
) => {
    
    while (
        t = [
            ...r[s].splice(0, ~~(Math.random() * (
                r[s].length > 3 ? 4 : r[s].length
            )) + 1),
            ...t
        ],
        s ^= 1,
        t.length < v.length
    );
    
    return t;
    
};
        </pre>
    
    </div>
    
    <div overhand class="qr">
        
        while in prison,
        the 17<sup>th</sup> century
        headless philosopher
        <a href="https://en.wikipedia.org/wiki/Naivety">
        Na&#239;vett&#233;</a> developed this
        ridiculous method of overhand shuffling,
        which added thirteen years to his sentence:
        <br><br>
        
        <pre>
            
const overhand = (v, a=[...v], b=[]) => {
        
    while (
        
        b = [
            ...a.splice(0, ~~(Math.random() * (a.length > 8 ? 8 : a.length)) + 1),
            ...b
        ],
            
        b.length < v.length
        
    );
        
    return b;
        
};
        </pre>
        
    </div>
    
    <div class="qr">
        
        <div>
            <svg viewbox="0,0,550,550" style="
                width:100%;
                transform: scale(-1, 1);
                --hull-color: var(--blackness);
                --tower-color: var(--midness);
                --rod-color: var(--midness);
                --window-visibility: visible;
                --window-color: rgba(255,255,255,0.03);
            ">
                <use data-nose=":root" xlink:href="yacht.svg#ikon" />
            </svg>
        </div>
    </div>
    
    <hr>
    <div id="dataDiv" class="qr"></div>

    <div id="sig" class="qr signature"><i>~queviva</i></div>

</div>
</body>

<script>

/////////////////////////////////////////////////////////{
// pizzaface
//
/////////////////////////////////////////////////////////}

new function () {

    // prefs {

    const loops = 100000;
    const trials = 5;
    const size = 5;
    const showTitle = size < 5;
    const showRands = false;
    
    const hiColor = 'var(--midness)';
    const loColor = 'var(--darkness)';
    
    const message = 'click to show raw & rerun';

    //}

    // utils {
    
    const log = console.log;
    const abs = Math.abs;
    const max = Math.max;

    const rand = () => [...crypto.getRandomValues(
        new Uint32Array(1)
    )].map(v => v / 4294967296.5)[0];

    const randArray = n => [...crypto.getRandomValues(
        new Uint32Array(n)
    )].map(v => v / 4294967296.5);

    const fact = n => [...new Array(n-2)].reduce((v, _, i) =>
        v * (i + 3)
    , 2);
    
    const perm = a => a.length ? a.flatMap(b =>
        perm(a.filter(c => c !== b)).map(d => [b, ...d])
    ).map(f => f.join('')) : [[]];
        

    // }
    
    // SHUFFLE {

    const shuffle = [
        
    (v, r=[...v]) => v.map(() =>
        r.splice(~~(Math.random() * r.length), 1)[0]
    ),
    
    v => [...v].map((x, i, r,
            j = ~~(Math.random() * (r.length - i)) + i
    ) => ([x, r[j]] = [r[j], x], x))
    
    ][0];
        
    //}

    // setup {
    
    const list = 'zyxwvutsrqp'.split('').splice(0, size);
    
    const perms = perm(list).reduce((o,k)=>({...o,[k]:0}),{});
    
    const ordList = Object.keys(perms).sort();
    
    const permLength = ordList.length;
    
    const perk = loops / permLength;

    const barH = parseInt(
        window.getComputedStyle(chart)
        .getPropertyValue('--barH'),10
    ) / 2;

    chart.style.gridTemplateColumns = 'repeat(' +
        permLength + ', 1fr)';

    chart.style.gridTemplateRows    = 'repeat(' +
        permLength + ', 1fr, auto)';

    const msg = document.createElement('div');
    msg.classList.add('msg');
            
    const txt = document.createElement('i');
    txt.classList.add('txt');
    txt.innerText = message;
    
    msg.appendChild(txt);
    
    //}
    
    // methods {
    
    const buildHead = () => {
    
        !showTitle ||
        
        ordList.forEach(v => {
    
            let tmp = document.createElement('div');
            tmp.innerHTML = v;
            tmp.style.color = '#fff';
            tmp.style.fontSize = '10px';
            chart.appendChild(tmp);
    
        });
    };
    
    const buildData = () => {
        
        let graph = { ...perms };
        
        for (let i=0; i < loops; i++) {
            
            graph[shuffle(list).join('')]++;
            
        }
        
        return graph;
        
    };
    
    const buildRows = () => {
        
        if (count < trials) {
        
            const x = buildData();
        
            Object.keys(x).forEach(k => x[k] -= perk);
        
            buildBars(x);
            
            if (showRands) {
        
                looping = setTimeout(() => {
                
                    const rands = { ...perms };
                
                    Object.keys(rands).forEach(k =>
                        rands[k] = rand() * 200 - 100
                    );
                
                    buildBars(rands);
                    
                    count++;
                    setTimeout(buildRows, 0);
                    
                }, 0);
        
            }
            else {
                count++;
                looping = setTimeout(buildRows, 0);
            }
        
            trialData.push(x);
        
        
        } else {
            
            chart.style.cursor = 'auto';
            chart.appendChild(msg);
        }
        
    };
    
    const buildBars = data => {
        
        const maxi = max(...(
            Object.values(data).map(v => abs(v))
        ));
        
        ordList.forEach(v => {

            let tmp = document.createElement('div');

            let bar = document.createElement('div');
            
            bar.style.fontSize = '10px';

            bar.style.height = barH * abs(data[v]) / maxi
                + 'px';

            if (data[v] >= 0) {

                bar.style.backgroundColor = hiColor;
                bar.style.bottom = '50%';

            }
            else {

                bar.style.backgroundColor = loColor;
                bar.style.top = '50%';

            }

            tmp.appendChild(bar);
            chart.appendChild(tmp);

        });
        
    };
    
    const genData = () => {
        clearTimeout(looping);
        chart.innerHTML = '';
        chart.style.cursor = 'wait';
        buildHead();
        count = 0;
        trialData = [];
        looping = setTimeout(buildRows, 0);
    }
    
    //}
    
    // looping vars {
    let looping, trialData, count;
    //}
    
    // add lizzers {
    
    sig.addEventListener('click', () => {
        sig.innerHTML = '~' +
        shuffle('queviva'.split('')).join('');
    });
    
    msg.addEventListener('click', () => {
        
        let dataCopy = [ ...trialData ];
        
        for (let i in dataCopy) {
            for (let j in dataCopy[i]) {
                dataCopy[i][j] = dataCopy[i][j].toFixed(3);
            }
        }
        
        dataDiv.innerHTML += (JSON.stringify(dataCopy))
        .replace(/,/g,', ');
        
        genData();
        
    });
    
    //}
    
    // init {

    genData();
    
    //}

    
}();

</script>

</html>
